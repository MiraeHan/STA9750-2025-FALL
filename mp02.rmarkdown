---
title: "The YIMBY Index: Ranking America‚Äôs Most Build-Friendly Cities"
subtitle: "Analyzing Rent Burden & Housing Growth in U.S. Metropolitan Areas"
author: Mirae Han
date: "`r format(Sys.time(), '%B %d, %Y')`"
format: 
  html: 
    code-tools: true
    code-fold: true
    toc: true
    toc-location: right
    number-sections: true
    toc-depth: 3
execute:
  eval: true
csl: apa.csl
---



# Task 1: Data Import

```{r, echo=TRUE, message=FALSE, warning=FALSE}
## Tidycensus package to download what we need.
  
  
  if(!dir.exists(file.path("data", "mp02"))){
  dir.create(file.path("data", "mp02"), showWarnings=FALSE, recursive=TRUE)
}

library <- function(pkg){
  ## Mask base::library() to automatically install packages if needed
  ## Masking is important here so downlit picks up packages and links
  ## to documentation
  pkg <- as.character(substitute(pkg))
  options(repos = c(CRAN = "https://cloud.r-project.org"))
  if(!require(pkg, character.only=TRUE, quietly=TRUE)) install.packages(pkg)
  stopifnot(require(pkg, character.only=TRUE, quietly=TRUE))
}

library(tidyverse)
library(glue)
library(readxl)
library(tidycensus)

get_acs_all_years <- function(variable, geography="cbsa",
                              start_year=2009, end_year=2023){
  fname <- glue("{variable}_{geography}_{start_year}_{end_year}.csv")
  fname <- file.path("data", "mp02", fname)
  
  if(!file.exists(fname)){
    YEARS <- seq(start_year, end_year)
    YEARS <- YEARS[YEARS != 2020] # Drop 2020 - No survey (covid)
    
    ALL_DATA <- map(YEARS, function(yy){
      tidycensus::get_acs(geography, variable, year=yy, survey="acs1") |>
        mutate(year=yy) |>
        select(-moe, -variable) |>
        rename(!!variable := estimate)
    }) |> bind_rows()
    
    write_csv(ALL_DATA, fname)
  }
  
  read_csv(fname, show_col_types=FALSE)
}

# Household income (12 month)
INCOME <- get_acs_all_years("B19013_001") |>
  rename(household_income = B19013_001)

# Monthly rent
RENT <- get_acs_all_years("B25064_001") |>
  rename(monthly_rent = B25064_001)

# Total population
POPULATION <- get_acs_all_years("B01003_001") |>
  rename(population = B01003_001)

# Total number of households
HOUSEHOLDS <- get_acs_all_years("B11001_001") |>
  rename(households = B11001_001)

#----------------------------------------------------------
## Download the number of new housing units built each year

  
library(dplyr)
library(purrr)
library(readr)
library(readxl)
library(stringr)
library(glue)
library(tidyr)

get_building_permits <- function(start_year = 2009, end_year = 2023){
  fname <- glue("housing_units_{start_year}_{end_year}.csv")
  fname <- file.path("data", "mp02", fname)
  
  if(!file.exists(fname)){
    HISTORICAL_YEARS <- seq(start_year, 2018)
    
    HISTORICAL_DATA <- map(HISTORICAL_YEARS, function(yy){
      historical_url <- glue("https://www.census.gov/construction/bps/txt/tb3u{yy}.txt")
      
      LINES <- readLines(historical_url)[-c(1:11)]
      
      CBSA_LINES <- str_detect(LINES, "^[[:digit:]]")
      CBSA <- as.integer(str_sub(LINES[CBSA_LINES], 5, 10))
      
      PERMIT_LINES <- str_detect(str_sub(LINES, 48, 53), "[[:digit:]]")
      PERMITS <- as.integer(str_sub(LINES[PERMIT_LINES], 48, 53))
      
      data_frame(CBSA = CBSA,
                 new_housing_units_permitted = PERMITS, 
                 year = yy)
    }) |> bind_rows()
    
    CURRENT_YEARS <- seq(2019, end_year)
    
    CURRENT_DATA <- map(CURRENT_YEARS, function(yy){
      current_url <- glue("https://www.census.gov/construction/bps/xls/msaannual_{yy}99.xls")
      
      temp <- tempfile()
      
      download.file(current_url, destfile = temp, mode="wb")
      
      fallback <- function(.f1, .f2){
        function(...){
          tryCatch(.f1(...), 
                   error=function(e) .f2(...))
        }
      }
      
      reader <- fallback(read_xlsx, read_xls)
      
      reader(temp, skip=5) |>
        na.omit() |>
        select(CBSA, Total) |>
        mutate(year = yy) |>
        rename(new_housing_units_permitted = Total)
    }) |> bind_rows()
    
    ALL_DATA <- rbind(HISTORICAL_DATA, CURRENT_DATA)
    
    write_csv(ALL_DATA, fname)
    
  }
  
  read_csv(fname, show_col_types=FALSE)
}

PERMITS <- get_building_permits()

#----------------------------------------------------------
## Download the latest NAICS data schema

library(httr2)
library(rvest)
get_bls_industry_codes <- function(){
  fname <- file.path("data", "mp02", "bls_industry_codes.csv")
  library(dplyr)
  library(tidyr)
  library(readr)
  
  if(!file.exists(fname)){
    
    resp <- request("https://www.bls.gov") |> 
      req_url_path("cew", "classifications", "industry", "industry-titles.htm") |>
      req_headers(`User-Agent` = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:143.0) Gecko/20100101 Firefox/143.0") |> 
      req_error(is_error = \(resp) FALSE) |>
      req_perform()
    
    resp_check_status(resp)
    
    naics_table <- resp_body_html(resp) |>
      html_element("#naics_titles") |> 
      html_table() |>
      mutate(title = str_trim(str_remove(str_remove(`Industry Title`, Code), "NAICS"))) |>
      select(-`Industry Title`) |>
      mutate(depth = if_else(nchar(Code) <= 5, nchar(Code) - 1, NA)) |>
      filter(!is.na(depth))
    
    # These were looked up manually on bls.gov after finding 
    # they were presented as ranges. Since there are only three
    # it was easier to manually handle than to special-case everything else
    naics_missing <- tibble::tribble(
      ~Code, ~title, ~depth, 
      "31", "Manufacturing", 1,
      "32", "Manufacturing", 1,
      "33", "Manufacturing", 1,
      "44", "Retail", 1, 
      "45", "Retail", 1,
      "48", "Transportation and Warehousing", 1, 
      "49", "Transportation and Warehousing", 1
    )
    
    naics_table <- bind_rows(naics_table, naics_missing)
    
    naics_table <- naics_table |> 
      filter(depth == 4) |> 
      rename(level4_title=title) |> 
      mutate(level1_code = str_sub(Code, end=2), 
             level2_code = str_sub(Code, end=3), 
             level3_code = str_sub(Code, end=4)) |>
      left_join(naics_table, join_by(level1_code == Code)) |>
      rename(level1_title=title) |>
      left_join(naics_table, join_by(level2_code == Code)) |>
      rename(level2_title=title) |>
      left_join(naics_table, join_by(level3_code == Code)) |>
      rename(level3_title=title) |>
      select(-starts_with("depth")) |>
      rename(level4_code = Code) |>
      select(level1_title, level2_title, level3_title, level4_title, 
             level1_code,  level2_code,  level3_code,  level4_code) |>
      drop_na() |>
      mutate(across(contains("code"), as.integer))
    
    write_csv(naics_table, fname)
  }
  
  read_csv(fname, show_col_types=FALSE)
}

INDUSTRY_CODES <- get_bls_industry_codes()

#----------------------------------------------------------
## Download the BLS Quarterly Census of Employment and Wages

library(httr2)
library(rvest)
get_bls_qcew_annual_averages <- function(start_year=2009, end_year=2023){
  fname <- glue("bls_qcew_{start_year}_{end_year}.csv.gz")
  fname <- file.path("data", "mp02", fname)
  
  YEARS <- seq(start_year, end_year)
  YEARS <- YEARS[YEARS != 2020] # Drop Covid year to match ACS
  
  if(!file.exists(fname)){
    ALL_DATA <- map(YEARS, .progress=TRUE, possibly(function(yy){
      fname_inner <- file.path("data", "mp02", glue("{yy}_qcew_annual_singlefile.zip"))
      
      if(!file.exists(fname_inner)){
        request("https://www.bls.gov") |> 
          req_url_path("cew", "data", "files", yy, "csv",
                       glue("{yy}_annual_singlefile.zip")) |>
          req_headers(`User-Agent` = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:143.0) Gecko/20100101 Firefox/143.0") |> 
          req_retry(max_tries=5) |>
          req_perform(fname_inner)
      }
      
      if(file.info(fname_inner)$size < 755e5){
        warning(sQuote(fname_inner), "appears corrupted. Please delete and retry this step.")
      }
      
      read_csv(fname_inner, 
               show_col_types=FALSE) |> 
        mutate(YEAR = yy) |>
        select(area_fips, 
               industry_code, 
               annual_avg_emplvl, 
               total_annual_wages, 
               YEAR) |>
        filter(nchar(industry_code) <= 5, 
               str_starts(area_fips, "C")) |>
        filter(str_detect(industry_code, "-", negate=TRUE)) |>
        mutate(FIPS = area_fips, 
               INDUSTRY = as.integer(industry_code), 
               EMPLOYMENT = as.integer(annual_avg_emplvl), 
               TOTAL_WAGES = total_annual_wages) |>
        select(-area_fips, 
               -industry_code, 
               -annual_avg_emplvl, 
               -total_annual_wages) |>
        # 10 is a special value: "all industries" , so omit
        filter(INDUSTRY != 10) |> 
        mutate(AVG_WAGE = TOTAL_WAGES / EMPLOYMENT)
    })) |> bind_rows()
    
    write_csv(ALL_DATA, fname)
  }
  
  ALL_DATA <- read_csv(fname, show_col_types=FALSE)
  
  ALL_DATA_YEARS <- unique(ALL_DATA$YEAR)
  
  YEARS_DIFF <- setdiff(YEARS, ALL_DATA_YEARS)
  
  if(length(YEARS_DIFF) > 0){
    stop("Download failed for the following years: ", YEARS_DIFF, 
         ". Please delete intermediate files and try again.")
  }
  
  ALL_DATA
}

WAGES <- get_bls_qcew_annual_averages()
```


# Task 2: Multi-Table Questions

## Q1. Which CBSA (by name) permitted the largest number of new housing units in the decade from 2010 to 2019 (inclusive)?
The Houston‚ÄìSugar Land‚ÄìBaytown, TX Metropolitan Area (CBSA 26420) permitted the largest number of new housing units during the decade from 2010 to 2019.

```{r, echo=TRUE, message=FALSE, warning=FALSE}
library(dplyr)

top_cbsa <- PERMITS |>
  filter(between(year, 2010, 2019)) |>
  group_by(CBSA) |>
  summarize(total_units = sum(new_housing_units_permitted, na.rm = TRUE), .groups = "drop") |>
  inner_join(HOUSEHOLDS, join_by ("CBSA" == "GEOID")) |>
  arrange(desc(total_units)) |>
  slice_head(n = 1)

top_cbsa |> summarize(result = paste(CBSA, NAME)) |> pull(result)
```

## Q2. In what year did Albuquerque, NM (CBSA Number 10740) permit the most new housing units?
Although 2021 recorded the highest number of new housing permits (4,021 units),this appears to be a COVID-19 data artifact,and the actual peak year is 2017.

```{r, echo=TRUE, message=FALSE, warning=FALSE}
library(dplyr)

cbsa_names <- POPULATION |>
  distinct(GEOID, NAME) |>
  mutate(GEOID = as.integer(GEOID))

albuquerque_top_year <- PERMITS |>
  filter(CBSA == 10740, year != 2021) |>  # exclude 2021
  group_by(CBSA, year) |>
  summarise(total_units = sum(new_housing_units_permitted, na.rm = TRUE), .groups = "drop") |>
  inner_join(cbsa_names, by = c("CBSA" = "GEOID")) |>  
  arrange(desc(total_units)) |>
  slice_head(n = 1)

albuquerque_top_year
```

*3. Which state (not CBSA) had the highest average individual income in 2015?
In 2015, the state with the highest average individual income was the District of Columbia

```{r, echo=TRUE, message=FALSE, warning=FALSE}
library(dplyr)
library(stringr)

state_df <- data.frame(
  abb  = c(state.abb, "DC", "PR"),
  name = c(state.name, "District of Columbia", "Puerto Rico")
)

cbsa_2015 <- INCOME |>
  inner_join(HOUSEHOLDS, by = c("GEOID", "NAME", "year")) |>
  inner_join(POPULATION, by = c("GEOID", "NAME", "year")) |>
  filter(year == 2015)

cbsa_2015_calc <- cbsa_2015 |>
  mutate(
    total_income_cbsa = household_income * households,
    state = str_extract(NAME, "(?<=, )[A-Z]{2}")  
  )

state_2015 <- cbsa_2015_calc |>
  group_by(state) |>
  summarise(
    total_income = sum(total_income_cbsa, na.rm = TRUE),
    total_population = sum(population, na.rm = TRUE),
    .groups = "drop"
  ) |>
  mutate(avg_individual_income = total_income / total_population) |>
  inner_join(state_df, by = c("state" = "abb")) |>
  arrange(desc(avg_individual_income))

top_state_2015 <- state_2015 |> slice_head(n = 1)

print(top_state_2015) 
```

*4. What is the last year in which the NYC CBSA had the most data scientists in the country? 
The last year New York had the most data scientists in the U.S. was 2015.

```{r, echo=TRUE, message=FALSE, warning=FALSE}
library(dplyr)
library(stringr)

WAGES_CLEAN <- WAGES |>
  mutate(CBSA_join = as.double(paste0(str_remove(FIPS, "^C"), "0")))

cbsa_names <- POPULATION |>
  distinct(GEOID, NAME) |>
  mutate(GEOID = as.double(GEOID))

data_sci <- WAGES_CLEAN |>
  filter(INDUSTRY == 5182) |>
  group_by(YEAR, CBSA_join) |>
  summarise(EMPLOYMENT = sum(EMPLOYMENT, na.rm = TRUE), .groups = "drop")

top_cbsa_each_year <- data_sci |>
  inner_join(cbsa_names, by = c("CBSA_join" = "GEOID")) |>
  group_by(YEAR) |>
  slice_max(EMPLOYMENT, n = 1, with_ties = FALSE) |>
  ungroup() |>
  select(YEAR, NAME, EMPLOYMENT)

nyc_last_year <- top_cbsa_each_year |>
  filter(str_detect(NAME, "New York")) |>
  summarise(last_year_nyc_led = max(YEAR, na.rm = TRUE))

top_cbsa_each_year
nyc_last_year
```

*5. What fraction of total wages in the NYC CBSA was earned by people employed in the finance and insurance industries (NAICS code 52)? In what year did this fraction peak? 
In the NYC CBSA, the finance and insurance industries made up 16% of total wages, peaking in 2021.

```{r, echo=TRUE, message=FALSE, warning=FALSE}
library(dplyr)
library(stringr)

WAGES_join <- WAGES |>
  mutate(CBSA_join = as.double(paste0(str_remove(FIPS, "C"), "0")))

nyc_wages <- WAGES_join |>
  filter(CBSA_join == 35620)

total_wages <- nyc_wages |>
  group_by(YEAR) |>
  summarise(total_wages_all = sum(TOTAL_WAGES, na.rm = TRUE), .groups = "drop")

finance_wages <- nyc_wages |>
  filter(str_starts(as.character(INDUSTRY), "52")) |>
  group_by(YEAR) |>
  summarise(total_wages_finance = sum(TOTAL_WAGES, na.rm = TRUE), .groups = "drop")

nyc_finance_fraction <- total_wages |>
  inner_join(finance_wages, by = "YEAR") |>
  mutate(fraction = total_wages_finance / total_wages_all,
         percent = fraction * 100) |>
  arrange(desc(fraction))

peak_year <- nyc_finance_fraction |> slice_head(n = 1)

peak_year
```


# Task 3: Initial Visualizations

*1. The relationship between monthly rent and average household income per CBSA in 2009. 
The scatterplot shows a clear positive relationship between median household income and monthly rent across CBSAs in 2009.
In general, areas with higher incomes also have higher rents. 
Since both axes are on a log scale, the relationship is roughly proportional ‚Äî when income doubles, rent tends to rise by about 1.5 to 2 times. 
Most points are close to the trend line, indicating a strong correlation, while a few outliers suggest local differences in housing markets or cost of living.

```{r, echo=TRUE, message=FALSE, warning=FALSE}
library(dplyr)
library(ggplot2)

rent_income_2009 <- RENT |>
  filter(year == 2009) |>
  select(GEOID, NAME, monthly_rent) |>
  inner_join(INCOME |> filter(year == 2009) |> select(GEOID, household_income),
             join_by("GEOID" == "GEOID")) |>
  filter(!is.na(monthly_rent), !is.na(household_income))

ggplot(rent_income_2009, aes(x = household_income, y = monthly_rent)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", se = FALSE) +
  labs(title = "Monthly Rent vs Household Income (CBSA, 2009)",
       x = "Median Household Income",
       y = "Median Monthly Rent") +
  theme_minimal()


ggplot(rent_income_2009, aes(household_income, monthly_rent)) +
   geom_point(alpha = 0.6) +
   geom_smooth(method = "lm", se = FALSE) +
   scale_x_log10() + scale_y_log10() +
   labs(title = "Monthly Rent vs Household Income (Log Scales, 2009)",
        x = "Median Household Income (log)",
        y = "Median Monthly Rent (log)") +
   theme_minimal()
```


*2. The relationship between total employment and total employment in the health care and social services sector (NAICS 62) across different CBSAs.

I selected the three most populous CBSAs and visualized how employment in the Health Care and Social Assistance sector (NAICS 62) changed over the last five years.
The bars show total employment in this sector, and the lines show its share of total employment in each CBSA.

From 2018 to 2023, both New York and Los Angeles saw growth in health and social services employment, with New York consistently leading in size and share. New York‚Äôs employment peaked in 2021 at 5.6 million (about 15% of total jobs) before slightly declining and recovering by 2023. Los Angeles also grew steadily from 3.6 to 4.0 million, with its share rising from 11.7% to 12.8%. Both cities hit their highest levels during the pandemic, reflecting increased healthcare demand, and have since stabilized at historically high levels.

```{r, echo=TRUE, message=FALSE, warning=FALSE}
library(dplyr)
library(ggplot2)
library(stringr)
library(scales)

yrs <- sort(unique(WAGES$YEAR))
latest_years <- tail(yrs[yrs != 2020], 5)

cbsa_names <- POPULATION |>
  filter(year == max(year, na.rm = TRUE)) |>
  distinct(GEOID, NAME) |>
  mutate(GEOID = as.integer(GEOID))

available_cbsa <- WAGES |>
  filter(YEAR %in% latest_years, str_starts(FIPS, "C")) |>
  transmute(CBSA = as.integer(paste0(str_sub(FIPS, 2), "0"))) |>
  distinct(CBSA)

top2_cbsa <- POPULATION |>
  filter(year %in% latest_years) |>
  group_by(GEOID, NAME) |>
  summarize(avg_pop = mean(population, na.rm = TRUE), .groups = "drop") |>
  mutate(GEOID = as.integer(GEOID)) |>
  semi_join(available_cbsa, join_by(GEOID == CBSA)) |>
  arrange(desc(avg_pop)) |>
  slice_head(n = 3) |>
  pull(GEOID)

wages_health <- WAGES |>
  filter(YEAR %in% latest_years, str_starts(FIPS, "C")) |>
  mutate(CBSA = as.integer(paste0(str_sub(FIPS, 2), "0"))) |>
  group_by(CBSA, YEAR) |>
  summarize(
    total_emp  = sum(EMPLOYMENT, na.rm = TRUE),
    health_emp = sum(EMPLOYMENT[str_starts(as.character(INDUSTRY), "62")], na.rm = TRUE),
    ratio = health_emp / total_emp,
    .groups = "drop"
  )

plot_data <- wages_health |>
  inner_join(cbsa_names, join_by(CBSA == GEOID)) |>
  filter(CBSA %in% top2_cbsa) |>
  mutate(City = str_trim(str_split_fixed(NAME, "‚Äì", 2)[,1])) |>
  select(City, YEAR, health_emp, ratio) |>
  arrange(City, YEAR)

k  <- max(plot_data$health_emp/1000, na.rm = TRUE) / max(plot_data$ratio, na.rm = TRUE)
pd <- position_dodge(width = 0.65)
bar_width <- 0.45

ggplot(plot_data, aes(x = factor(YEAR))) +
  geom_col(aes(y = health_emp/1000, fill = City),
           width = bar_width, position = pd, alpha = 0.70) +
  geom_text(aes(y = health_emp/1000, label = comma(health_emp), group = City),
            position = pd, vjust = -0.25, size = 3.1,
            color = "black", fontface = "bold") +
  geom_line(aes(y = ratio * k, color = City, group = City),
            position = pd, linewidth = 1.2) +
  geom_point(aes(y = ratio * k, color = City),
             position = pd, size = 2.2) +
  geom_text(aes(y = ratio * k, label = percent(ratio, accuracy = 0.1),
                color = City, group = City),
            position = pd, vjust = -0.6, size = 3.1,
            show.legend = FALSE, color = "black", fontface = "bold") +
  scale_y_continuous(
    name = "Employment in Health/Social (Thousands)",
    sec.axis = sec_axis(~ . / k, name = "Share of Total Employment (%)",
                        labels = percent_format(accuracy = 0.1))
  ) +
  labs(
    title = "Health & Social Services Employment ‚Äî Top 2 CBSAs (by Population)",
    subtitle = paste0("Employment (bars) & Share (lines), ",
                      min(latest_years), "‚Äì", max(latest_years)),
    x = "Year", fill = "City", color = "City"
  ) +
  coord_cartesian(ylim = c(2000000/1000, NA)) +
  theme_minimal(base_size = 13) +
  theme(legend.position = "bottom")
```

*3. The evolution of average household size over time. Use different lines to represent different CBSAs. For a point of extra credit, use the gghighlight package to highlight the NYC and Los Angeles CBSAs in your visualization of household size over time.

The chart shows how average household size changed across U.S. metro areas from 2009 to 2023.
Los Angeles (red) consistently had larger households, around 3.1‚Äì3.3 people, but has slowly declined since 2016.
New York (blue) maintained smaller households, around 2.6‚Äì2.8 people, with a slight drop after 2018.
Both cities show a gradual decrease, likely reflecting more single-person and smaller families.

```{r, echo=TRUE, message=FALSE, warning=FALSE}
library(dplyr)
library(ggplot2)
library(stringr)
library(scales)
library(gghighlight)

HH_SIZE <- POPULATION |>
  filter(year != 2020) |>
  select(GEOID, NAME, year, population) |>
  inner_join(
    HOUSEHOLDS |> filter(year != 2020) |> select(GEOID, year, households),
    join_by("GEOID" == "GEOID", "year" == "year")
  ) |>
  mutate(household_size = population / households) |>
  drop_na()

HH_SIZE <- HH_SIZE |>
  mutate(City = case_when(
    str_detect(NAME, "^New York") ~ "New York",
    str_detect(NAME, "^Los Angeles") ~ "Los Angeles",
    TRUE ~ str_trim(str_split_fixed(NAME, "‚Äì", 2)[, 1])
  ))

ggplot(HH_SIZE, aes(x = year, y = household_size, color = City, group = NAME)) +
  geom_line(linewidth = 0.9) +
  gghighlight(
    City %in% c("New York", "Los Angeles"),
    unhighlighted_params = list(color = "#b0c4de", alpha = 0.3, linewidth = 0.5),
    use_direct_label = TRUE, label_key = City
  ) +
  scale_color_manual(
    values = c("New York" = "#1f78b4",    
               "Los Angeles" = "#e31a1c") 
  ) +
  scale_y_continuous(labels = number_format(accuracy = 0.1)) +
  labs(
    title = "Average Household Size Over Time ‚Äî Highlighting NYC & LA",
    subtitle = "ACS 1-year estimates (CBSA 2009‚Äì2023)",
    x = "Year",
    y = "Average Household Size (persons per household)"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "none",
    plot.title.position = "plot",
    axis.title = element_text(color = "#333333"),
    axis.text = element_text(color = "#333333")
  )
```


# Task 4: Rent Burden


## 

This code calculates a rent-burden index and shows results in two tables.

It first joins ACS income and rent data by CBSA and year, computing the rent-to-income ratio. The baseline year (first ACS year excluding 2020) is used to standardize values‚Äîsetting the national average that year to 100. Each CBSA‚Äôs rent burden is then expressed relative to that baseline.

For Q1, it displays the yearly rent burden for the New York‚ÄìNewark‚ÄìJersey City metro area in an interactive table with currency and percentage formatting.
For Q2, it finds the CBSAs with the highest and lowest rent burden in the most recent year, presenting them side-by-side for quick comparison.

```{r, echo=TRUE, message=FALSE, warning=FALSE}
library(dplyr)
library(stringr)
library(scales)
library(DT)

### Join INCOME + RENT and compute rent-to-income
rent_burden_raw <- INCOME |>
  select(GEOID, year, household_income) |>
  inner_join(RENT |> select(GEOID, year, monthly_rent),
             join_by("GEOID" == "GEOID", "year" == "year")) |>
  mutate(rent_to_income = monthly_rent / (household_income / 12)) |>
  filter(!is.na(rent_to_income))

### Standardization: Baseline = 2009 national average (excluding 2020)
baseline_year <- rent_burden_raw |>
  filter(year != 2020) |>
  summarise(min_year = min(year, na.rm = TRUE)) |>
  pull(min_year)

baseline_ratio <- rent_burden_raw |>
  filter(year == baseline_year) |>
  summarise(b = mean(rent_to_income, na.rm = TRUE)) |>
  pull(b)

### Scaling: Normalize relative to the baseline year (set baseline = 100)
rent_burden_idx <- rent_burden_raw |>
  mutate(rent_burden_index = 100 * rent_to_income / baseline_ratio)

### Tables with DT


## (Q1) Pick a single Metropolitan Area and see how rent burden has changed over time
## In 2009, the New York‚ÄìNewark‚ÄìJersey City area‚Äôs rent burden was about 10% above the national average, showing already high housing costs.
## By 2023, the index rose to 114.6, about 4% higher than 2009, meaning rent grew slightly faster than income but the burden increase was modest overall.

target_cbsa <- "New York-Newark-Jersey City, NY-NJ-PA Metro Area"

table_one <- rent_burden_idx |>
  inner_join(POPULATION |> distinct(GEOID, NAME),
             join_by("GEOID" == "GEOID")) |>
  filter(NAME == target_cbsa) |>
  arrange(year) |>
  select(year, monthly_rent, household_income, rent_to_income, rent_burden_index)

datatable(table_one, rownames = FALSE,
          caption = htmltools::tags$caption(
            paste0("Rent Burden Over Time ‚Äî ", target_cbsa,
                   " (Baseline Year = ", baseline_year, ")")),
          options = list(pageLength = 20, dom = "tip")) |>
  formatCurrency("monthly_rent", currency = "$", digits = 0) |>
  formatCurrency("household_income", currency = "$", digits = 0) |>
  formatPercentage("rent_to_income", digits = 1) |>
  formatRound("rent_burden_index", digits = 1)

## (Q2) Highlight the Metro Areas highest and lowest with the highest and lowest rent burden

latest_year <- rent_burden_idx |>
  filter(year != 2020) |>
  summarise(latest = max(year, na.rm = TRUE)) |>
  pull(latest)

hi_lo <- rent_burden_idx |>
  filter(year == latest_year) |>
  inner_join(POPULATION |> distinct(GEOID, NAME),
             join_by("GEOID" == "GEOID")) |>
  select(NAME, year, rent_to_income, rent_burden_index)

highest_row <- hi_lo |>
  arrange(desc(rent_burden_index), desc(rent_to_income), NAME) |>
  slice(1) |>
  mutate(Group = "Highest")

lowest_row <- hi_lo |>
  arrange(rent_burden_index, rent_to_income, NAME) |>
  slice(1) |>
  mutate(Group = "Lowest")

table_two <- bind_rows(highest_row, lowest_row) |>
  mutate(Group = factor(Group, levels = c("Highest", "Lowest"))) |>
  arrange(Group)

datatable(
  table_two, 
  rownames = FALSE,
  caption = htmltools::tags$caption(
    style = 'caption-side: top; text-align: left; font-weight: bold; font-size: 16px;',
    paste0("Highest & Lowest Metro Areas by Rent Burden ‚Äî ", latest_year)
  ),
  options = list(pageLength = 2, dom = "t")
) |>
  formatPercentage("rent_to_income", digits = 1) |>
  formatRound("rent_burden_index", digits = 1)

```


# Task 5: Housing Growth

##

This code measures housing growth across CBSAs and identifies which cities are more ‚Äúbuilding-friendly.‚Äù

It joins population and building permit data, calculates 5-year population growth, and removes missing or zero values. Two indicators are then computed:

Instant growth: permits per person.

Rate growth: permits per 5-year population change.

Both are standardized (z-scores) and summed into a composite score, where higher values mean faster housing expansion.
Finally, it lists the top 10 and bottom 10 CBSAs for the most recent year in an interactive table.

```{r, echo=TRUE, message=FALSE, warning=FALSE}
library(dplyr)
library(DT)
library(RcppRoll)

## Join POPULATION and PERMITS tables
housing_raw <- POPULATION |>
  mutate(GEOID = as.integer(GEOID)) |>
  select(GEOID, NAME, year, population) |>
  inner_join(
    PERMITS |> select(CBSA, year, new_housing_units_permitted),
    join_by(GEOID == CBSA, year == year)
  ) |>
  rename(permits = new_housing_units_permitted) |>
  arrange(GEOID, year)

## Compute 5-year population growth
housing_raw <- housing_raw |>
  group_by(GEOID) |>
  mutate(pop_growth_5yr = population - dplyr::lag(population, 5)) |>
  ungroup()

# Optional: Apply a 5-year rolling average to smooth noisy data
housing_smoothed <- housing_raw |>
  group_by(GEOID) |>
  mutate(
    permits_5yr_avg    = RcppRoll::roll_meanr(permits,    n = 5, fill = NA),
    population_5yr_avg = RcppRoll::roll_meanr(population, n = 5, fill = NA)
  ) |>
  ungroup()

## Remove invalid observations (NA or zero values)
housing_growth <- housing_smoothed |>
  filter(!is.na(pop_growth_5yr), pop_growth_5yr != 0,
         !is.na(permits), permits > 0,
         !is.na(population), population > 0) |>

## Instantaneous metric: permits per person 
## Rate-based metric: permits per 5-year population change
## (negative values indicate construction slower than population loss) 
  mutate(
    instant_growth = permits / population,

    rate_growth = permits / pop_growth_5yr
  )

## Standardize metrics (Z-scores) and create a composite index
## Z-scores normalize each metric (mean = 0, sd = 1)
## Composite score C = Z_instant + Z_rate
## >0 means "Building-Friendly", <0 means "Not Friendly"
housing_growth <- housing_growth |>
  mutate(
    z_instant = as.numeric(scale(instant_growth)),
    z_rate    = as.numeric(scale(rate_growth)),
    composite_score = z_instant + z_rate,
    friendly_flag   = if_else(composite_score > 0, "Building-Friendly", "Not Friendly")
  )

## Identify top and bottom CBSAs for the most recent year
latest_year <- housing_growth |>
  summarise(max(year, na.rm = TRUE)) |>
  pull()

table_latest <- housing_growth |>
  filter(year == latest_year) |>
  select(NAME, year, instant_growth, rate_growth, composite_score, friendly_flag) |>
  arrange(desc(composite_score))

## Create summary tables (Top 10 / Bottom 10)
table_top_bottom <- bind_rows(
  table_latest |> slice_head(n = 10) |> mutate(Group = "Highest"),
  table_latest |> slice_tail(n = 10) |> mutate(Group = "Lowest")
) |>
  arrange(desc(Group), desc(composite_score))

## Display interactive table (DT)
datatable(
  table_top_bottom,
  rownames = FALSE,
  caption = htmltools::tags$caption(
    style = 'caption-side: top; text-align: left; font-weight: bold; font-size: 16px;',
    paste0("Top & Bottom CBSAs by Building-Friendliness ‚Äî ", latest_year,
           " (Zeros/NA excluded)")
  ),
  options = list(pageLength = 20, dom = "tip")
) |>
  formatRound(c("instant_growth", "rate_growth", "composite_score"), digits = 3)
```


# Task 6: Visualization

This code visualizes how housing growth and rent burden interact across U.S. metro areas.

The first plot compares each CBSA‚Äôs change in rent burden (x-axis) and average housing growth (y-axis), with bubble size showing population growth. Cities in the upper-left quadrant built housing fast enough to reduce rent burden‚Äîpotential ‚ÄúYIMBY success stories.‚Äù

The second plot aggregates these results by state, ranking the Top 10 YIMBY-oriented states using a composite score that combines rent burden reduction, housing growth, and population growth.

```{r, echo=TRUE, message=FALSE, warning=FALSE}
## Visualization 1 -----------------------------------------

## The plot shows that CBSAs in the upper-left region‚Äîparticularly several smaller metros like Salisbury and Hammond‚Äî
## built housing rapidly enough that rent burdens fell despite population growth, illustrating potential ‚ÄúYIMBY success stories.‚Äù

## Tables
library(dplyr)

## Define early and late periods
early_years <- 2009:2012
late_years  <- 2021:2023

## Extract unique CBSA names
cbsa_names <- POPULATION |> distinct(GEOID, NAME)

## Rent Burden Summary
rb_summary <- rent_burden_idx |>
  filter(year != 2020) |>
  group_by(GEOID) |>
  summarize(
    rb_early = mean(rent_burden_index[year %in% early_years], na.rm = TRUE),
    rb_late  = mean(rent_burden_index[year %in% late_years],  na.rm = TRUE),
    .groups = "drop"
  ) |>
  mutate(
    rb_delta = rb_late - rb_early
  ) |>
  filter(is.finite(rb_early), is.finite(rb_late), is.finite(rb_delta))

## Population Summary
pop_summary <- POPULATION |>
  filter(year != 2020) |>
  group_by(GEOID) |>
  summarize(
    pop_first_year = min(year, na.rm = TRUE),
    pop_last_year  = max(year, na.rm = TRUE),
    pop_start = first(population[year == pop_first_year]),
    pop_end   = first(population[year == pop_last_year]),
    .groups = "drop"
  ) |>
  mutate(
    pop_change_abs = pop_end - pop_start,
    pop_change_pct = ifelse(pop_start > 0, (pop_end - pop_start)/pop_start, NA_real_)
  )

## Housing Growth Summary
hg_summary <- housing_growth |>
  filter(year >= 2014) |>
  group_by(GEOID) |>
  summarize(hg_avg = mean(composite_score, na.rm = TRUE), .groups = "drop") |>
  filter(is.finite(hg_avg))

## Combine and Clean Up
library(tidyr)

summary_cbsa <- rb_summary |>
  inner_join(pop_summary, by = "GEOID") |>
  inner_join(hg_summary,  by = "GEOID") |>
  inner_join(cbsa_names,  by = "GEOID") |>
  filter(is.finite(rb_delta), is.finite(hg_avg)) |>
  mutate(
    # Flag CBSAs with early rent burden in top 25%
    early_high_flag = rb_early >= quantile(rb_early, 0.75, na.rm = TRUE),
    # Clean population growth percentage (non-negative)
    size_var = pmax(0, pop_change_pct),
    size_var = replace_na(size_var, 0)
  ) |>
  filter(is.finite(size_var))

## National mean of housing growth (for reference line)
hg_mean_all <- mean(summary_cbsa$hg_avg, na.rm = TRUE)

## Plot with Safety Checks
library(ggplot2)
library(stringr)
library(scales)

p1 <- summary_cbsa |>
  ggplot(aes(x = rb_delta, y = hg_avg)) +
  # Reference lines
  geom_hline(yintercept = hg_mean_all, linetype = "dashed", linewidth = 0.6) +
  geom_vline(xintercept = 0, linetype = "dashed", linewidth = 0.6) +
  # Scatter points
  geom_point(
    aes(size = size_var, color = early_high_flag),
    alpha = 0.75,
    na.rm = TRUE
  ) +
  # Color and size scales
  scale_color_manual(
    values = c("TRUE" = "#d62728", "FALSE" = "#8da0cb"),
    labels = c("TRUE" = "High Early Rent Burden", "FALSE" = "Others"),
    name   = "Early Rent Burden"
  ) +
  scale_size_continuous(
    range = c(1.8, 9),
    limits = c(0, max(summary_cbsa$size_var, na.rm = TRUE)),
    labels = percent_format(accuracy = 1),
    name = "Population Growth (%)"
  ) +
  # Titles and labels
  labs(
    title = "YIMBY Quadrant ‚Äî Rent Burden Change vs Housing Growth",
    subtitle = "Left = Rent burden ‚Üì ; Up = Housing growth ‚Üë ; Size = Population growth",
    x = "Change in Rent Burden Index (Late ‚àí Early) ‚Üí lower is better",
    y = "Average Housing Growth (Composite Score)"
  ) +
  theme_minimal(base_size = 13)

p1

## Add Labels (Optional, without ggrepel)
yimby_candidates <- summary_cbsa |>
  filter(early_high_flag, rb_delta < 0, pop_change_abs > 0, hg_avg > hg_mean_all)

top_labels <- yimby_candidates |>
  arrange(rb_delta, desc(hg_avg), desc(pop_change_abs)) |>
  slice_head(n = 10)

p1_labels <- p1 +
  geom_text(
    data = top_labels,
    aes(label = str_remove(NAME, " Metro Area$")),
    check_overlap = TRUE,
    position = position_nudge(x = -0.02, y = 0.02),
    size = 3.2,
    fontface = "bold",
    na.rm = TRUE
  )

p1_labels


## Visualization 2 -------------------------------------------------------------

## Top 10 YIMBY-Oriented States
library(dplyr)
library(stringr)
library(ggplot2)

## Compute YIMBY composite score by CBSA
yimby_score <- summary_cbsa |>
  mutate(
    yimby_score = as.numeric(scale(-rb_delta) + scale(hg_avg) + scale(size_var))
  )

## Extract state abbreviation from NAME (e.g., ", FL" ‚Üí "FL")
yimby_score <- yimby_score |>
  mutate(
    state = str_extract(NAME, "(?<=, )[A-Z]{2}")
  ) |>
  filter(!is.na(state))

## Aggregate to state-level (mean score across CBSAs)
state_yimby <- yimby_score |>
  group_by(state) |>
  summarise(
    avg_yimby_score = mean(yimby_score, na.rm = TRUE),
    high_burden_share = mean(early_high_flag, na.rm = TRUE),  # share of high-burden CBSAs
    .groups = "drop"
  ) |>
  arrange(desc(avg_yimby_score)) |>
  slice_head(n = 10)  # üîπ Top 10 States

## Plot
ggplot(state_yimby, aes(x = reorder(state, avg_yimby_score),
                        y = avg_yimby_score,
                        fill = high_burden_share)) +
  geom_col(alpha = 0.85) +
  coord_flip() +
  scale_fill_gradient(
    low = "#377eb8", high = "#e31a1c",
    name = "Share of High Early Rent Burden CBSAs",
    labels = scales::percent_format(accuracy = 1)
  ) +
  labs(
    title = "Top 10 YIMBY-Oriented States",
    subtitle = "Average Composite Score = (-ŒîRent Burden) + Housing Growth + Population Growth",
    x = "State",
    y = "Average YIMBY Composite Score (standardized)"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    legend.position = "right",
    plot.title.position = "plot",
    panel.grid.minor = element_blank()
  )

```

# Task 7: Policy Brief





























